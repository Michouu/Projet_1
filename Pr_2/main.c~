#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <net/if.h>
#include <sys/ioctl.h>

#include <linux/can.h>
#include <linux/can/raw.h>
#include <sys/types.h>

#include "fonctions.h"

#define CAN_RAW 1
#define CAN_SRAW 7
 

struct
{
  char Nom_interface[5];
  int Id;
  unsigned char taille;
  unsigned char data[8];
  long sec_tps;
  int usec_tps;
} Tst_trame;

/*argv un tableau de pointeurs   argc indique le nbr de chaines de cara sur lequel pointe argv*/
int
main (int argc, char *argv[])
{
  int i, j, l;
  int sock;
  int nbytes, opt;
  char *N_interf = NULL;
  char *file = NULL;
  int time = NULL;
  int protocole = CAN_RAW;
  int t_tamp = 0;
  int difference = 0;



  struct sockaddr_can addr;
  struct can_frame frame;	// création de la variable frame / celle que j'utilise pour remplir ma trame
  struct ifreq ifr;

  while ((opt = getopt (argc, argv, "i:f:t:z:S?")) != -1)	// parser la ligne de commande 
    {
      switch (opt)
	{
	case 'i':
	  N_interf = optarg;
	  break;

	case 'f':
	  file = optarg;
	  break;

	case 't':
	  time = atoi (optarg);
	  break;

	case 'z':
	  protocole = atoi (optarg);
	  break;

	case 'S':
	  t_tamp = 1;
	  break;

	case '?':

	default:
	  printf ("\n");
	  utility ();
	  printf ("\n");
	  return 1;
	  break;

	}

    }
  printf ("\t N_interf = %s, file = %s, time = %d, protocol = %d\n", N_interf,
	  file, time, protocole);

  if ((sock = socket (PF_CAN, SOCK_RAW, protocole)) < 0)	//création de socket
    {
      perror ("socket");	// print error, sert au traitement des erreurs
      return 1;
    }

  addr.can_family = AF_CAN;

  strcpy (ifr.ifr_name, N_interf);	// N_interf = argv[1]
  if (ioctl (sock, SIOCGIFINDEX, &ifr) < 0)
    {
      perror ("SIOCGIFINDEX");
      return 1;
    }

  addr.can_ifindex = ifr.ifr_ifindex;

  if (bind (sock, (struct sockaddr *) &addr, sizeof (addr)) < 0)	// lier à un point de communication défini
    {
      perror ("bind");
      return 1;
    }


  FILE *fichier = NULL;

  if (argc > 1)
    {
      fichier = fopen (file, "r");	// permet de mettre mon fichier en paramètre et de l'ouvrir
    }
  printf (" \t Ce fichier a ete compile le %s a %s \n\n", __DATE__, __TIME__);


  if (fichier != NULL)
    {

      while (!feof (fichier))	// lecture jusqu'à la fin du fichier
	{
	  if (t_tamp == 1)
	    {
	      fscanf (fichier, " (%ld.%d) %s  %x  [%hhx]", &Tst_trame.sec_tps,
		      &Tst_trame.usec_tps, Tst_trame.Nom_interface,
		      &Tst_trame.Id, &Tst_trame.taille);

	      printf (" La trame est la suivante : (%ld.%d) %s %x [%x]",
		      Tst_trame.sec_tps, Tst_trame.usec_tps,
		      Tst_trame.Nom_interface, Tst_trame.Id,
		      Tst_trame.taille);

	     /* difference = diff(Tst_trame.usec_tps, Tst_trame.sec_tps);
	      printf ("Diff = %d \n", difference);*/

	    }

	  else
	    {
	      fscanf (fichier, " %s  %x  [%hhx]", Tst_trame.Nom_interface, &Tst_trame.Id, &Tst_trame.taille);	// lit et affecte dans une variable

	      if (Tst_trame.taille > 8)	// condition pour la taille
		{
		  fclose (fichier);
		}
	      else
		{

		  printf (" La trame est la suivante :" "%s %x [%x]",
			  Tst_trame.Nom_interface, Tst_trame.Id,
			  Tst_trame.taille);
		}
	    }

	  for (i = 0; i < Tst_trame.taille; i++)	//2eme boucle
	    {
	      fscanf (fichier, " %hhx ", &Tst_trame.data[i]);	// hhx pour 8 bits        // lit et affecte dans une variable
	      printf (" %02x ", Tst_trame.data[i]);	// affichage de la fin de la trame

	    }
	  printf ("\n");



	  frame.can_id = Tst_trame.Id;	// remplissage de frame
	  frame.can_dlc = Tst_trame.taille;	// remplissage de frame
	  /*printf (" Frame.id = %02x , Frame.taille = [%x] ",
	     frame.can_id, frame.can_dlc); */

	  for (l = 0; l < Tst_trame.taille; l++)

	    {

	      frame.data[l] = Tst_trame.data[l];	// remplissage de frame
	      //printf ("Frame [%d] : %02x ", l, frame.data[l]);

	    }
	  nbytes = write (sock, &frame, sizeof (frame));	//écriture de socket
	  if (nbytes < 0)
	    {
	      if (errno = ENOBUFS)	//gérer la mémoire vive
		{
		  sched_yield ();	//provoque le thread

		}
	      else
		{
		  perror ("write");

		}

	    }
	  sleep (time);	// attente entre chaques écritures des trames
	  printf ("\n\n");

	}


      close (sock);

    }
  else
    {

      perror ("Impossible d'ouvrir le fichier candump \n");


    }
  fclose (fichier);		// fermeture du fichier

  return 0;
}
